# xpmem_rw_586.py — R/W hunter v5.8.6 (IDA 7.6–8.x)
# Fix: use idc.get_segm_start/end instead of idaapi.get_segm_start/end
# Also includes: 7.7-safe xref usage, device string harvest, dispatcher + v5.4 heuristics,
# and C++ header emission with device paths & any recognized IOCTLs.

import idaapi, idautils, idc
import ida_funcs, ida_name, ida_bytes, ida_ua, ida_search, ida_nalt, ida_xref

OUT_HPP = (ida_nalt.get_input_file_path() or "xpmem").rsplit('.',1)[0] + "_user.hpp"
STRICT_DISPATCHER_ONLY = False
MAX_CALL_XREFS = 2000

TARGET_APIS = [
    "memmove", "memcpy", "RtlCopyMemory",
    "ZwMapViewOfSection", "MmMapViewOfSection",
    "ZwUnmapViewOfSection", "MmUnmapViewOfSection",
    "MmCopyVirtualMemory",
    "ProbeForRead", "ProbeForWrite",
    "PsLookupProcessByProcessId",
]

def ea_name(ea):
    return ida_name.get_ea_name(ea) or ida_funcs.get_func_name(ea) or "sub_%X" % ea

def _all_ida_strings():
    s = idautils.Strings()
    try:
        s.setup(); s.refresh()
    except Exception:
        pass
    for si in s:
        try:
            yield str(si)
        except Exception:
            continue

def discover_device_strings():
    devs = set()
    for s in _all_ida_strings():
        if not s:
            continue
        s2 = s.replace("\x00", " ")
        if "\\\\.\\" in s2:
            for tok in s2.split():
                if tok.startswith("\\\\.\\" ):
                    devs.add(tok)
        if "\\Device\\" in s2:
            for tok in s2.split():
                if tok.startswith("\\Device\\"):
                    devs.add(tok)
    out = []
    for d in sorted(devs):
        if 1 <= len(d) <= 120 and all((32 <= ord(ch) < 127) or ch == '\\' for ch in d):
            out.append(d)
    return out

def _enum_import_eas_by_name(want_names):
    want = set(want_names)
    hits = []
    for name in want:
        ea = ida_name.get_name_ea(idaapi.BADADDR, name)
        if ea != idaapi.BADADDR:
            hits.append((name, ea))
    qty = ida_nalt.get_import_module_qty()
    for i in range(qty):
        def cb(ea, name, ordno):
            if not name:
                return True
            if name in want:
                hits.append((name, ea))
            return True
        ida_nalt.enum_import_names(i, cb)
    seen = set(); res=[]
    for n,ea in hits:
        k=(n,ea)
        if k in seen: continue
        seen.add(k); res.append((n,ea))
    return res

def _calls_to(ea_target):
    res=[]
    try:
        for frm in idautils.CodeRefsTo(ea_target, 0):
            res.append(frm)
            if len(res) > MAX_CALL_XREFS: break
        if res:
            return res
    except Exception:
        pass
    try:
        for xr in idautils.XrefsTo(ea_target, 0):
            try:
                if ida_xref.iscode(xr.type):
                    res.append(xr.frm)
                    if len(res) > MAX_CALL_XREFS: break
            except Exception:
                continue
    except Exception:
        pass
    return res

def heuristic_rw_api_hits():
    hits=[]
    for name, ea_imp in _enum_import_eas_by_name(TARGET_APIS):
        for callsite in _calls_to(ea_imp):
            f = ida_funcs.get_func(callsite)
            if not f: continue
            hits.append((name, callsite, f.start_ea))
    for name in ["memmove", "memcpy", "RtlCopyMemory"]:
        ea = ida_name.get_name_ea(idaapi.BADADDR, name)
        if ea != idaapi.BADADDR:
            for callsite in _calls_to(ea):
                f = ida_funcs.get_func(callsite)
                if not f: continue
                hits.append((name, callsite, f.start_ea))
    seen=set(); out=[]
    for n,c,fs in hits:
        k=(n,c,fs)
        if k in seen: continue
        seen.add(k); out.append((n,c,fs))
    return out

def try_find_dispatchers():
    cands=[]
    for fstart in idautils.Functions():
        f = ida_funcs.get_func(fstart)
        if not f: continue
        cnt=0; ea=f.start_ea
        while ea < f.end_ea:
            insn = ida_ua.insn_t()
            if ida_ua.decode_insn(insn, ea):
                for op in insn.ops:
                    if op.type == ida_ua.o_imm:
                        v = op.value
                        if 0x00220000 <= v <= 0x0022FFFF:
                            cnt += 1
            ea += idaapi.get_item_size(ea)
        if cnt >= 8:
            cands.append((cnt, fstart))
    cands.sort(reverse=True)
    return [ea for _,ea in cands]

def emit_header(dev_paths, ioctls):
    default = ""
    for p in dev_paths:
        if p.startswith("\\\\.\\"):
            default = p; break
    if not default and dev_paths:
        for p in dev_paths:
            if p.startswith("\\Device\\"):
                default = "\\\\.\\" + p.split("\\")[-1]
                break
    if not default:
        default = "\\\\.\\EBIoDispatch"

    try:
        with open(OUT_HPP, "w", encoding="utf-8") as fp:
            fp.write("// Generated by xpmem_rw_586.py\n#pragma once\n#include <cstdint>\n#include <string>\n#include <vector>\n\n")
            fp.write("namespace xpmem {\n")
            fp.write('static const wchar_t* kDefaultDevicePath = L"%s";\n' % default.replace("\\","\\\\"))
            fp.write("static const std::vector<std::wstring> kAllDevicePaths = {\n")
            for p in dev_paths:
                fp.write('  L"%s",\n' % p.replace("\\","\\\\"))
            fp.write("};\n\n")
            fp.write("struct ioctl_desc { uint32_t code; const char* name; const char* method; const char* access; const char* tag; };\n")
            if ioctls:
                fp.write("inline std::vector<ioctl_desc> known_ioctls() { return {\n")
                for d in ioctls:
                    fp.write('  { 0x%08X, "%s", "%s", "%s", "%s" },\n' %
                             (d["code"], d["name"], d["method"], d["access"], d["tag"]))
                fp.write("}; }\n")
            else:
                fp.write("inline std::vector<ioctl_desc> known_ioctls() { return {}; }\n")
            fp.write("} // namespace xpmem\n")
        print("[+] C++ header emitted: %s" % OUT_HPP)
    except Exception as e:
        print("[error] writing header: %s" % e)

def main():
    print("[*] R/W hunter v5.8.6 — dispatcher + fallback heuristics")

    devs = discover_device_strings()
    if devs:
        print("[+] Device string candidates (%d):" % len(devs))
        for d in devs: print("    %s" % d)

    ioctls = []

    dsp = try_find_dispatchers()
    if dsp:
        print("[i] Dispatcher candidate: %s @ 0x%X" % (ea_name(dsp[0]), dsp[0]))
    else:
        print("[!] No dispatcher with IOCTL mapping found.")
        if STRICT_DISPATCHER_ONLY:
            emit_header(devs, ioctls); print("\n=== SUMMARY ===\n[*] Done. (dispatcher-only)"); return

    hits = heuristic_rw_api_hits()
    if hits:
        print("[+] Direct calls found: %d" % len(hits))
        for n,call,fs in hits:
            print("  - %s call at 0x%X in %s" % (n, call, ea_name(fs)))
    else:
        print("[i] No direct memmove/ZwMapView/MmCopyVirtualMemory calls recovered.")

    # Search for ACPI IOCTL signature (0x426F6541) across segments (7.7-safe)
    ACPI = 0x426F6541
    b0 = "%02X %02X %02X %02X" % (ACPI & 0xFF, (ACPI>>8)&0xFF, (ACPI>>16)&0xFF, (ACPI>>24)&0xFF)
    found = False
    for seg_start in idautils.Segments():
        seg_end = idc.get_segm_end(seg_start)
        ea = ida_search.find_binary(seg_start, seg_end, b0, 16, ida_search.SEARCH_DOWN)
        if ea != idaapi.BADADDR:
            found = True
            break
    if found:
        ioctls.append(dict(code=ACPI, name="IOCTL_DEV_426F_FUNC_950_METHOD_IN_DIRECT_FILE_READ_ACCESS",
                           method="METHOD_IN_DIRECT", access="FILE_READ_ACCESS", tag="ACPI?"))

    emit_header(devs, ioctls)
    print("\n=== SUMMARY ===")
    if hits:   print("[*] %d direct R/W-adjacent calls" % len(hits))
    if ioctls: print("[*] %d IOCTL(s) exported to header" % len(ioctls))
    if not hits and not ioctls:
        print("[i] No strong indicators; header still includes device paths.")

if __name__ == "__main__":
    main()
